\documentclass{article}
\usepackage{xypic}
\usepackage{listings}
\title{Theo III - Blatt 2}
\author{Benjamin Möller \& Nick Daiber}

\begin{document}
\maketitle
\section*{1}
\subsection*{a}
\begin{verbatim}
    func merge(l1, l2) {
        list res
        n = len(l1)
        m = len(l2)
        index1 = 0
        index 2 = 0
        while (index 1 < n and index2 < m) {
            // Größtes Element in res
            if (l1[index1] <= l2[index2]) {
                res[index1 + index2] = l1[index1]
                index1++
            }
            else {
                res[index1 + index2] = l2[index2]
                index2++
            }
        }
        // verbleibende Elemente anhängen
        if (index1 == n) {
            append(res, l2[index2+])
        }
        else {
            append(res, l1[index1+])
        }
        return res
    }
\end{verbatim}

Dabei gilt die Anzahl an Vergleichen $V \leq |l1| + |l2| = m+n \Rightarrow V\in O(n+m)$
\newpage
\subsection*{b}
\begin{lstlisting}[mathescape=true]
    func mergeLists(Number[][] lists, left, right) {
        if (left == right) {
            return lists[left]
        }
        mid = $\lfloor$ left + (right - left) / 2 $\rfloor$

        Number[] leftMerged = mergeLists(lists, left, mid)
        Number[] rightMerged = mergeLists(lists, mid + 1, right)

        return merge(leftMerged, rightMerged)
    }
\end{lstlisting}
\subsection*{c}
\begin{itemize}
    \item {Die delete-Routine entfernt ein gegebenes Element aus dem Baum,
    indem sie das Element in $O(n)$ Operationen findet, löscht und das letzte Element des Baumes
    an dessen Stelle schreibt und dann wieder für die Heapeigenschaft sorgt.}
    \item {Die change-key-Routine ändert den Wert für ein gegebenes Element aus dem Baum,
    indem das Element gefunden wird, dessen Wert überschrieben wird und zuletzt die 
    Heapeigenschaft wieder hergestellt wird.}
\end{itemize}
\newpage
\subsection*{d}
Für einen ternären Heap gilt $v$ Elternknoten mit kindern $s_0,s_1,s_2$.\\
$s_0 = 3\cdot v + 1, s_1 = 3\cdot v+2, s_3=3\cdot v+3$
\begin{figure}[h!]
    \xymatrix{
        &&&&0\ar[dlll]\ar[d]\ar[drrr]\\
        &1\ar[dl]\ar[d]\ar[dr]&&&2\ar[dl]\ar[d]\ar[dr]&&&3\ar[dl]\ar[d]\ar[dr]\\
        4&5&6&7&8&9&10&11&12
    }
    \caption{Darstellung ternärer Heap als Baum mit Index}
\end{figure}
\section*{2}
\subsection*{a} 
Größtes Element wird nach oben durchgereicht.\\
Induktion über $n$ für $n=1$ trivial
für $n=n+1$ ist die liste für $j=n$ sortiert
$n+1$ wird "durchgereicht"
\subsection*{b}
\subsubsection*{best case}
$A$ bereits sortiert, nur $j=1$ bis $n-1\Rightarrow n-1$ vergleiche
\subsubsection*{worst case}
$A$ "absteigend sortiert für $j=1$ bis $n-1$ jeweils
$j-1$ vergleiche, also $\frac{(n-1)(j-1)}{2}$ vergleiche

\section*{3}

\end{document}