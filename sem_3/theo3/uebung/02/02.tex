\documentclass{article}
\usepackage{xypic}
\begin{document}
\section{}
\subsection*{a}
\begin{verbatim}
    func merge(l1, l2) {
        list res
        while (|l1| > 0 and |l2| > 0) {
            // Größtes Element in res[n+m]
            if (l1[0] > l2[0]) {
                /*
                    append geht in O(1), da die Größe von
                    res bekannt und zu beginnt allokiert werden kann.
                    In tatsächlichem Code muss der aktuelle Index
                    von res natürlich gespeichert werden.
                /*
                append(res, l1[0])
                /* 
                    annahme eines Datentypen, 
                    bei dem remove an stelle 0 in O(1) möglich ist
                    falls dies nicht möglich ist
                    müssen die Listen von hinten populiert werden
                    und l1[n] entfernt werden.
                */ 
                remove(l1, 0)
            }
            else {
                append(res, l2[0])
                remove(l2, 0)
            }
        }
        // falls l1 leer ist, wird l2 komplett an res angehängt
        if (|l1| = 0) {
            append(res, l2)
        }
        else {
            append(res, l1)
        }
        return res
    }
\end{verbatim}
\newpage
\subsection*{b}
\begin{verbatim}
    /* 
        hier als kurzschreibweise für eine funktion mit 2 bis k parametern.
        Dabei wird angenommen, dass k eine zweierpotenz ist
    */
    func mergeK(l1, ..., lk) {
        if (k = 2) {
            // also nur 2 listen übergeben
            return merge(l1, l2) // merge aus Aufgabenteil a
        }
        else {
            /*
                Es werden jeweils k/2 listen zusammengesetzt.
                Nach der Rekursion geschieht ausgabe als eine Liste.
            */
            return merge(
                mergeK(l1, ..., l(k/2)),
                mergeK(l(k/2+1), ..., lk)
            )
        }
    }
\end{verbatim}
\subsection*{c}
Die delete-Routine entfernt das kleinste Element im Heap.
Dabei wird das Minimum der untersten Ebene des Heaps 
(als Baumdarstellung) ermittelt und dieses entfernt.
Im Speicher sind dies die letzten $\frac{n}{2}$ Speicherzellen.
\subsection*{d}
Für einen ternären Heap gilt $v$ Vaterknoten mit Söhnen $s_0,s_1,s_2$.\\
$s_0 = 3\cdot v + 1, s_1 = 3\cdot v+2, s_3=3\cdot v+3$
\begin{figure}[h!]
    \xymatrix{
        &&&&0\ar[dlll]\ar[d]\ar[drrr]\\
        &1\ar[dl]\ar[d]\ar[dr]&&&2\ar[dl]\ar[d]\ar[dr]&&&3\ar[dl]\ar[d]\ar[dr]\\
        4&5&6&7&8&9&10&11&12
    }
    \caption{Darstellung ternärer Heap als Baum mit Index}
\end{figure}
\end{document}